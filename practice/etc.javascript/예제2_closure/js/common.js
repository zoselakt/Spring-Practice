'use strict'
//------------------------------------------------------------------------------------------------
// 매개변수가 있는 일반적인 함수 작성
// function outFunc(a){ 
//     let outerText = a;
//     console.log(outerText);
//     function innerFunc(){ //내부함수작성 / 파라미터 x
//         let innerText = 'inner-text';
//         console.log(`${outerText}`, `${innerText}`); //내부함수에서 부모와 자신을 호출
//     }
//     innerFunc(); // 내부함수 부모영역호출
// }
// outFunc('외부함수');
//------------------------------------------------------------------------------------------------

// function outFunc(a){
//     let outerText = "outer-text";
//     function innerFunc(num){
//         let innerText = num;
//         console.log(`${outerText}`, `${innerText}`);
//     }
//     innerFunc(a);
// }
// outFunc('내부함수'); // 내부함수 외부호출
//-------------------------------------------------------------------------------------------------
// closure 적용
function outFunc(){ // 파라미터없는 함수 / 여기서 실행해도 매개변수가 없기때문에 아무런 실행이 되지 않는다.
    let outerText = "outer-text";
    function innerFunc(a){ // a의 파라미터 던지기 함수
        let innerText = `innerText`;
        console.log(`${outerText}, ${a}`);
    }
    return innerFunc; // a 파라미터 던지기 / 종료된 함수를 외부로 던져서 외부에서 받을수 있다.
}
let closureFunc = new outFunc(); // outFunc을 객체화 하여 함수 밖에서 함수 값을 사용하게끔 변수에 담는다.
closureFunc('클로저 함수 호출'); // return으로 받은값

//중첩함수
/*
변수선언이름과 동일한 함수명을 사용할 수 없다. 동일한 함수명을 사용할 경우 변수로 사용된다.
중첩함수는 외부에서 내부함수를 호출할 수 없다. 내부에서만 호출할 수 있다.
*/
// 클로저
/*
1. 함수를 중첩으로 사용하여 외부와 단절시킴
2. return을 사용하여 외부에 함수를 노출, 외부에서 매개변수 등을 통하여 내부함수에 접근할 수 있다.
3. 함수를 생성자를 통해서 만들경우 함수를 만들어내는 공장과 같다
4. class와 유사 : 객체의 형태를 제공 -> 내부함수가 그 역할을 한다.

- 자바스크립트는 함수를 리턴하고, 리턴하는 함수가 클로저를 형성한다. = 함수지향 프로그래밍 관련
- 클로저는 어떤 데이터(어휘적 환경)와 그 데이터를 조작하는 함수를 연관시켜주기 때문에 유용하다.
하나 혹은 그 이상의 메소드들을 연관시킨다는 점에서 객체지향 프로그래밍과 분명히 같은 맥락에 있다.
결론적으로 오직 하나의 메소드를 가지고 있는 객체를 일반적으로 사용하는 모든 곳에 클로저를 사용할 수 있다.
프론트 엔드 자바스크립트에서 우리가 쓰는 많은 코드가 이벤트 기반이다. 우리는 몇 가지 동작을 정의한 다음 사용자에 의한 이벤트에(클릭 혹은 키 누르기 같은) 연결한다. 
우리의 코드는 일반적으로 콜백으로 첨부된다: 이벤트에 응답하여 실행되는 단일 함수다.
*/

function outFunc1(x){
    const y = 5;
    function innerFunc2(z){
        return x + y + z;
    }
    return innerFunc2;
}
let makeAdder10 = new outFunc(10); // 생성자로 인스턴스생성
console.log(makeAdder10(2));

/*자바스크립트는 태생적으로는 이런 방법을 제공하지 않지만 클로저를 이용하여 프라이빗 메소드를 흉내내는 것이 가능하다. 
프라이빗 메소드는 코드에 제한적인 접근만을 허용한다는 점 뿐만 아니라 전역 네임 스페이스를 관리하는 강력한 방법을 
제공하여 불필요한 메소드가 공용 인터페이스를 혼란스럽게 만들지 않도록 한다.
*/

//내부함수를 리턴하지 않을때 데이터타입은 객체 / 리턴할때 데이터타입은 함수
let closureFunct = new outFunc1(10);